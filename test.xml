<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Duane Newman</title>
    <link>http://duanenewman.net/</link>
    <description>Recent content on Duane Newman</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright Duane Newman</copyright>
    <lastBuildDate>Tue, 12 Feb 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="http://duanenewman.net/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Processing collections with LINQ using the Aggregate extension method</title>
      <link>http://duanenewman.net/blog/post/processing-collections-with-linq-using-the-aggregate-extension-method/</link>
      <pubDate>Wed, 14 Sep 2011 22:19:00 +0000</pubDate>
      
      <guid>http://duanenewman.net/blog/post/processing-collections-with-linq-using-the-aggregate-extension-method/</guid>
      <description>Everyone knows one of the easiest ways to process collections of objects is using foreach, it is much more elegant and less error prone (IMHO) than using a for (int x..) and looping by index. &amp;nbsp;However, sometimes you get forced into using the indexer to process a collection. &amp;nbsp;This usually happens when you need to look at the current object in context of the previous. &amp;nbsp;
The need to use the indexer and have code like obj[i] == obj[i -1] bugged me.</description>
      
      <category>dotnet</category>
      
      <category>linq</category>
      
    </item>
    
    <item>
      <title>Attaching to external DirectShow graphs using Graph Edit</title>
      <link>http://duanenewman.net/blog/post/attaching-to-external-directshow-graphs-using-graph-edit/</link>
      <pubDate>Wed, 14 Sep 2011 18:00:00 +0000</pubDate>
      
      <guid>http://duanenewman.net/blog/post/attaching-to-external-directshow-graphs-using-graph-edit/</guid>
      <description>In my day job I work on a product that does a lot of video work and in fact has a custom DirectShow player that gets all our video into WPF. &amp;nbsp;It plays multiple files all synchronized (a real challenge).
While looking into ways to improve performance I found myself needing to see how my filter graph was being built. &amp;nbsp;I did a little looking and found that creating an instance of DsROTEntry with a reference to the graph makes it available for external viewing.</description>
      
      <category>media</category>
      
      <category>directshow</category>
      
      <category>dotnet</category>
      
    </item>
    
  </channel>
</rss>