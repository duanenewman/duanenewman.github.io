<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lock on Duane Newman</title>
    <link>https://duanenewman.net/tags/lock/</link>
    <description>Recent content in Lock on Duane Newman</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>Copyright Duane Newman</copyright>
    <lastBuildDate>Tue, 19 Feb 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://duanenewman.net/tags/lock/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Concurrent Reads and Locked Writes with In-Memory Objects</title>
      <link>https://duanenewman.net/blog/post/concurrent-reads-and-locked-writes-with-in-memory-objects/</link>
      <pubDate>Tue, 19 Feb 2019 00:00:00 +0000</pubDate>
      <guid>https://duanenewman.net/blog/post/concurrent-reads-and-locked-writes-with-in-memory-objects/</guid>
      <description>The Problem On a recent project one of our clients had implemented an in-memory cache of some high read, low write data. The ultimate solution they had was a List&amp;lt;T&amp;gt; that they could search against while periodically updating when the database was updated. The reads worked great and were incredibly fast. The trouble came when they started to implement the updates. This was in their API layer and so incoming calls were on multiple threads.</description>
    </item>
  </channel>
</rss>
